/**
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 **/
        
/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.ricston.cassandradb.cql;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.inject.Inject;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mule.DefaultMuleEvent;
import org.mule.DefaultMuleMessage;
import org.mule.api.ConnectionException;
import org.mule.api.MuleContext;
import org.mule.api.MuleEvent;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.display.Password;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.expression.ExpressionManager;
import org.mule.util.StringUtils;

import com.datastax.driver.core.AuthProvider;
import com.datastax.driver.core.BoundStatement;
import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.PlainTextAuthProvider;
import com.datastax.driver.core.PreparedStatement;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;

/**
 * Cassandra CQL Connector
 *
 * @author MuleSoft, Inc.
 */
@Connector(name="cassandradbcql", schemaVersion="1.0-SNAPSHOT", friendlyName="cassandradbcql")
public class CassandraDbCqlConnector
{
    /**
     * Host name to connect to
     */
    @Configurable
    @Default(value="localhost")
    private String host;
    
    /**
     * Port number to connect to
     */
    @Configurable
    @Default(value="9042")
    private Integer port;
    
    /**
     * Keyspace to use
     */
    @Optional
    @Configurable
    private String keyspace;
    
    private Cluster cluster;
    
    protected static Log logger = LogFactory.getLog(CassandraDbCqlConnector.class);
    
    private Map<PreparedStatementKey, PreparedStatement> preparedStatements = new ConcurrentHashMap<PreparedStatementKey, PreparedStatement>();
    
    /**
     * Mule Expression Manager
     */
    @Inject
    private ExpressionManager expressionManager;
    
    /**
	 * Mule Context
	 */
	@Inject
    private MuleContext context;

    /**
     * Connect
     *
     * @param username A username
     * @param password A password
     * @throws ConnectionException
     */
    @Connect
    public void connect(@ConnectionKey String username, @Password @Optional String password)
        throws ConnectionException {
    	
    	Cluster.Builder builder = Cluster.builder()
    			.addContactPoint(host)
    			.withPort(port);
    	
    	if (StringUtils.isNotBlank(password)){
    		AuthProvider authProvider = new PlainTextAuthProvider(username, password);
    		builder = builder.withAuthProvider(authProvider);
    	}
    	
		cluster = builder.build();
		CassandraDbCqlUtils.logClusterInformation(cluster);
    }

    /**
     * Disconnect
     */
    @Disconnect
    public void disconnect() {
    	logger.info("Closing cluster " + cluster.getClusterName());
    	cluster.close();
    }

    /**
     * Are we connected
     */
    @ValidateConnection
    public boolean isConnected() {
    	return (cluster != null && !cluster.isClosed());
    }

    /**
     * Connection identifier
     */
    @ConnectionIdentifier
    public String connectionId() {
        return "na";
    }

    /**
     * Execute any CQL statement
     * 
     * {@sample.xml ../../../doc/CassandraDbCql-connector.xml.sample cassandradbcql:execute-cql}
     * 
     * @param cql The CQL statement to execute
     * @param event The current Mule Event
     * @return List of Maps with results, each map represents a row, each entry in the map represents a column
     */
    @Processor
    @Inject
    public List<Map<String,Object>> executeCql(String cql, List<String> params, @Default(value="false") boolean bulkMode, MuleEvent event){
    	
    	//get mule context and expression manager
    	//TODO: these should  be automatically injected using @Inject
    	MuleContext context = event.getMuleContext();
    	ExpressionManager expressionManager = context.getExpressionManager();
    	
		List<Object> evaluatedParameters = new ArrayList<Object>();
		int batchSize = 1;
		
		//if not in bulk mode, evaluate the expression for each parameter
		if (!bulkMode)
		{
			for(String expression : params){
				logger.debug("Evaluating: " + expression);
				evaluatedParameters.add(expressionManager.evaluate(expression, event));
			}
		}
		//if in bulk mode, evaluate the expression for each item in the list payload
		else{
			@SuppressWarnings("unchecked")
			List<Object> listPayload = (List<Object>) event.getMessage().getPayload();
			batchSize = listPayload.size();
			
			for(Object payload : listPayload){
				for(String expression : params){
					logger.debug("Evaluating: " + expression);
					evaluatedParameters.add(expressionManager.evaluate(expression, new DefaultMuleEvent(new DefaultMuleMessage(payload, context), event)));
				}
			}
		}
		
		//execute the statement using the evaluated parameters
		List<Row> result = cassandraExecuteStatement(cql, evaluatedParameters, batchSize);
		
		//convert result to list of maps and return
		return CassandraDbCqlUtils.toMaps(result);
	}
    
	public List<Row> cassandraExecuteStatement(String cql, List<Object> parameters, int batchSize) {

		logger.debug("Executing statement: " + cql);

		//get session and prepared statement
		Session session = getSession();
		PreparedStatement statement = getPreparedStatement(cql, batchSize, session);

		//bind the parameters
		BoundStatement boundStatement = new BoundStatement(statement);
		boundStatement = boundStatement.bind(parameters.toArray());
		
		//execute statement
		ResultSet resultSet = session.execute(boundStatement);

		//read all results
		List<Row> rowList = resultSet.all();
		
		//close session and return
		session.close();
		return rowList;
	}
	
	/**
	 * Get Cassandra session
	 * 
	 * @return Cassandra Session
	 */
	protected Session getSession(){
		
		//if keyspace is not set, get a general session
		if (StringUtils.isBlank(keyspace)){
			return cluster.connect();
		}
		
		//if keyspace is set, get a session for that keyspace
		return cluster.connect(keyspace);
	}
    
	/**
	 * Get a prepared statement from the cache if possible, if not, create it and put in cache
	 * 
	 * @param cql
	 * @param batchSize
	 * @param session
	 * @return
	 */
    protected PreparedStatement getPreparedStatement(String cql, int batchSize, Session session){
		
    	PreparedStatementKey key = new PreparedStatementKey(cql, batchSize);
		PreparedStatement statement = preparedStatements.get(key);
		
		if (statement == null){
			String fullCql = makeStatment(cql, batchSize);
			statement = session.prepare(fullCql);
			preparedStatements.put(key, statement);
		}
		
		return statement;
	}
    
    /**
     * Make string CQL depending on the batch size
     * 
     * @param cql
     * @param batchSize
     * @return
     */
    protected String makeStatment(String cql, int batchSize){
    	if (batchSize == 1){
    		return cql;
    	}
    	
    	// add ';' at the end of the statement if not present
		cql = StringUtils.trim(cql);
		if (!StringUtils.endsWith(cql, "; ")) {
			cql += ";";
		}

		// repeat the statement for the number of batches we need to execute
		StringBuilder batchCql = new StringBuilder();
		for (int i = 0; i < batchSize; i++) {
			batchCql.append(cql);
		}
		
		//surround with BEGIN BATCH & APPLLY BATCH
		return "BEGIN BATCH " + batchCql.toString() + "APPLY BATCH";
    }

    /**
     * 
     * @return
     */
	public String getHost() {
		return host;
	}

	/**
	 * 
	 * @param host
	 */
	public void setHost(String host) {
		this.host = host;
	}

	/**
	 * 
	 * @return
	 */
	public Integer getPort() {
		return port;
	}

	/**
	 * 
	 * @param port
	 */
	public void setPort(Integer port) {
		this.port = port;
	}

	/**
	 * 
	 * @return
	 */
	public String getKeyspace() {
		return keyspace;
	}

	/**
	 * 
	 * @param keyspace
	 */
	public void setKeyspace(String keyspace) {
		this.keyspace = keyspace;
	}

	/**
	 * 
	 * @return
	 */
	public Cluster getCluster() {
		return cluster;
	}

	/**
	 * 
	 * @param cluster
	 */
	public void setCluster(Cluster cluster) {
		this.cluster = cluster;
	}

	/**
	 * 
	 * @param expressionManager
	 */
	public void setExpressionManager(ExpressionManager expressionManager) {
		this.expressionManager = expressionManager;
	}

	/**
	 * 
	 * @param context
	 */
	public void setContext(MuleContext context) {
		this.context = context;
	}
	
}
